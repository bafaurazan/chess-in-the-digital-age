---
title: "Szachy w erze cyfrowej"
subtitle: "Wpływ mediów społecznościowych i internetu w rozwój szachów,<br />
jak te dane wykorzystać i jak wprowadzić nowość w szachach.<br /><br />"
author: "Rafal Bazan"
date: "2024-05-21"
output: html_document
---

# Css

<button id="button_my_css" class="my_button" onclick="hideCss()">Pokaż</button>

<div id="my_css">

```{css}
.my_button {
  background-color: #4CAF50;
  color: white;
  padding: 10px;
  font-size: 14px;
  border: none;
  cursor: pointer;
  width: 70px;
}
h1, h2, h3, h4, h5, h6 {
      text-align: center;
    }
body {
  background-color: #FFFFDF;
}
table {
   margin:1em auto;
}
```
#### Java-script dla przycisku

```{js, eval=FALSE}
const div_my_css = document.getElementById("my_css");
  div_my_css.style.display = 'none';
  
var button_my_css = document.getElementById("button_my_css");
  
function hideCss() {
  if (div_my_css.style.display === 'none') {
    div_my_css.style.display = 'block';
    button_my_css.innerHTML = "Ukryj";
  } else {
    div_my_css.style.display = 'none';
    button_my_css.innerHTML = "Pokaż";
  }
}
```

</div>

```{js, echo=FALSE}
const div_my_css = document.getElementById("my_css");
  div_my_css.style.display = 'none';
  
var button_my_css = document.getElementById("button_my_css");
  
function hideCss() {
  if (div_my_css.style.display === 'none') {
    div_my_css.style.display = 'block';
    button_my_css.innerHTML = "Ukryj";
  } else {
    div_my_css.style.display = 'none';
    button_my_css.innerHTML = "Pokaż";
  }
}
```

# Tworzenie struktury zbioru danych

<button id="my_button" class="my_button" onclick="myFunction()">Pokaż</button>

<div id="tworzenie-struktury">

#### Definiowanie ścieżek

```{r setup}
project_path = "D:/moje/projekty/chess-in-the-digital-age"
setwd(paste(project_path,"/presentation", sep = ""))
Dataset_path = paste(project_path,"/Dataset", sep = "")
selected_date = "2024-04"

knitr::opts_chunk$set(root= paste(project_path,"/presentation", sep = ""))
```

#### Definiowanie paczek

```{r message=FALSE}
library(pander)
panderOptions('digits',7)
library(knitr)
library(rvest)
library(stringi)
library(dplyr)
```

#### Wybór tablicy do scrapowania

```{r}
url = "https://database.lichess.org"
path= "/html/body/div/div[2]/div/section[1]/table"
wezel = html_node(read_html(url), xpath=path)
```

#### wyodrębnianie tagów oraz hiperłączy

```{r}
hyperlinks = html_nodes(wezel, "a")
my_href = html_attr(hyperlinks, "href")

pander(head(bind_rows(lapply(html_attrs(hyperlinks), function(x) data.frame(as.list(x), stringsAsFactors=FALSE)))))
```

#### Łączenie zmiennych w gotowy do pobrania link

```{r}
links = data.frame(links = paste(url,my_href,sep="/"))
pander(head(links))
```

#### Wybór wersji pobierania (.zst.torrent) w funkcji ograniczającej scrapowanie względem wybranej daty

```{r warning=FALSE}

choose_max_date_to_scrap = function(date){
  
  # co drugi link to .zst.torrent wiec go wyodrebniam
  init_links_for_download = links[seq(2,nrow(links), by=2), 1]
  
  full_date_from_imported_links = data.frame(stri_match_all(data.frame(init_links_for_download),
                                     regex = "rated_\\s*(.*?)\\s*[.]"))[,2]
  
  date_location = which(stri_detect(full_date_from_imported_links, regex = date) == TRUE) 
  
  my_links_for_download = init_links_for_download[c(date_location:length(init_links_for_download))]
  
  return(my_links_for_download)
}

links_for_download = choose_max_date_to_scrap(selected_date)
pander(data.frame(prepared_links = head(links_for_download)))
```

#### Wyodrębianie daty ze scrapowania

```{r warning=FALSE}
full_date_from_imported_links = data.frame(stri_match_all(data.frame(links_for_download),
                                     regex = "rated_\\s*(.*?)\\s*[.]"))[,2]
pander(head(data.frame(full_date_from_imported_links)))
```

#### Wyodrębianie roku, miesięcy, nazw miesięcy ze scrapowania

```{r warning=FALSE}
year_from_imported_links = data.frame(stri_match_all(data.frame(links_for_download),
                                     regex = "rated_\\s*(.*?)\\s*[-]"))[,2]
pander(head(data.frame(year_from_imported_links)))

month_from_imported_links = data.frame(stri_match_all(data.frame(links_for_download),
                                     regex = "-\\s*(.*?)\\s*[.]"))[,2]
pander(head(data.frame(month_from_imported_links)))

my_month_names = month.abb[as.integer(month_from_imported_links)]
pander(head(data.frame(my_month_names)))
```

#### Tworzenie struktury plików - lata

```{r}
my_paths_year <- unique(paste(Dataset_path,"/",year_from_imported_links, sep=""))
pander(data.frame(my_paths_year))

create_folders_year = function(){
  for(i in 1:length(my_paths_year)){
    dir.create(my_paths_year[i])
  }
}
```

#### Tworzenie struktury plików - miesiące

```{r}
my_paths_month <- paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names, sep="")
pander(head(data.frame(my_paths_month)))

create_folders_month = function(){
  for(i in 1:length(my_paths_month)){
    dir.create(my_paths_month[i])
  }
}

```

#### Definiowanie ścieżek do których będą pobierane pliki i definiowanie ich docelowych nazw

```{r}
my_paths = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/lichess_db_standard_rated_",full_date_from_imported_links,".pgn.zst.torrent", sep="")
pander(head(data.frame(my_paths)))



downloading = function(){
  create_folders_year()
  create_folders_month()
  for(j in 1:length(my_paths)){
    download.file(links_for_download[j], my_paths[j], mode="wb",Sys.sleep(0.2))
  }
}
```

#### Tworzenie struktury plikow i pobieranie w niej zbiorów danych

```{r warning=FALSE,eval=FALSE}
downloading()

```

#### Java-script dla przycisku

```{js eval=FALSE}
const my_div1 = document.getElementById("tworzenie-struktury");
  my_div1.style.display = 'none';
  
var button = document.getElementById("my_button");
  
function myFunction() {
  if (my_div1.style.display === 'none') {
    my_div1.style.display = 'block';
    button.innerHTML = "Ukryj";
  } else {
    my_div1.style.display = 'none';
    button.innerHTML = "Pokaż";
  }
}
```

</div>

```{js, echo=FALSE}
const my_div1 = document.getElementById("tworzenie-struktury");
  my_div1.style.display = 'none';
  
var button = document.getElementById("my_button");
  
function myFunction() {
  if (my_div1.style.display === 'none') {
    my_div1.style.display = 'block';
    button.innerHTML = "Ukryj";
  } else {
    my_div1.style.display = 'none';
    button.innerHTML = "Pokaż";
  }
}
```

# Przygotowywanie zbiorów danych do użycia 

<button id="my_button2" class="my_button" onclick="myFunction2()">Pokaż</button>

<div id="przygotowywanie-zbiorow">

#### Pobieranie informacji o liczbie partii poprzez scrapowanie oraz ograniczenie tego scrapowania względem wybranej daty

```{r warning=FALSE}

choose_max_date_to_scrap_game_count = function(date){
  my_games_count = html_table(wezel)[[3]]
  
  init_links_for_download = links[seq(2,nrow(links), by=2), 1]
  
  full_date_from_imported_links = data.frame(stri_match_all(data.frame(init_links_for_download),
                                     regex = "rated_\\s*(.*?)\\s*[.]"))[,2]
  
  date_location = which(stri_detect(full_date_from_imported_links, regex = date) == TRUE) 
  
  games_count = my_games_count[c(date_location:length(init_links_for_download))]
  
  return(games_count)
}

games_count = choose_max_date_to_scrap_game_count(selected_date)
pander(head(data.frame(games_count)))

```

#### funkcja do ograniczania danych dla konkretnego zbioru względem miesiąca

```{r warning=FALSE}

preparing_month_dataset = function(date, data_size = 0.001){
  searching_location = which(stri_detect(full_date_from_imported_links, regex = date) == TRUE) 
  decreasing_game_number <- round((as.numeric(stri_replace_all(games_count,"",regex = "\\,"))*18*data_size)[searching_location])
  
  pgn_file_to_read = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/lichess_db_standard_rated_",full_date_from_imported_links,".pgn", sep="")[searching_location]
  
  my_pgn <- read.table(pgn_file_to_read,
                   quote="", sep="\n", stringsAsFactors=FALSE, nrows = decreasing_game_number)
  
  
  colnms <- sub("\\[(\\w+).+", "\\1", my_pgn[(decreasing_game_number-22):decreasing_game_number,1])
  
  Event_location = which(stri_detect(colnms, regex = "Event") == TRUE) 
  
  my_pgn2 = my_pgn[1:(decreasing_game_number-22+Event_location-2),]
  
  tail(my_pgn2)
  
  pgn_file_to_write = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/Data_",date,".pgn", sep="")[searching_location]
  
  write.table(my_pgn2,pgn_file_to_write,col.names = FALSE,row.names = FALSE,quote = FALSE)
  
  test_path = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/Data_",date,".pgn", sep="")[searching_location]
  
  file_txt_for_info = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/ograniczono_dane.txt", sep="")[searching_location]
  
  write.table(" ",file_txt_for_info)
  
  testing_last_char <- read.table(test_path,
                   quote="", sep="\n", stringsAsFactors=FALSE)
  return(tail(testing_last_char))
}
```

#### funkcja do usuwania oryginalnego zbioru danych względem miesiąca

```{r}
removing_oryginal_dataset = function(date){
  searching_location = which(stri_detect(full_date_from_imported_links, regex = date) == TRUE) 
  
  file_pgn_zst_to_remove = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/lichess_db_standard_rated_",full_date_from_imported_links,".pgn.zst", sep="")[searching_location]
  
  file_pgn_to_remove = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/lichess_db_standard_rated_",full_date_from_imported_links,".pgn", sep="")[searching_location]
  
  file_txt_for_info = paste(Dataset_path,"/",year_from_imported_links,"/",month_from_imported_links,". ",my_month_names,"/usunieto_oryginal.txt", sep="")[searching_location]
  
  file.remove(file_pgn_zst_to_remove)
  
  file.remove(file_pgn_to_remove)
  
  write.table(" ",file_txt_for_info)
}
```

#### Wywoływanie funkcji przygotowującej zbiór z konkretnego miesiąca do późniejszej analizy

```{r eval=FALSE}
preparing_month_dataset("2023-09")

removing_oryginal_dataset("2023-09")
```

#### Java-script dla przycisku

```{js eval=FALSE}
const my_div2 = document.getElementById("przygotowywanie-zbiorow");
  my_div2.style.display = 'none';
  
var button2 = document.getElementById("my_button2");
  
function myFunction2() {
  if (my_div2.style.display === 'none') {
    my_div2.style.display = 'block';
    button2.innerHTML = "Ukryj kod";
  } else {
    my_div2.style.display = 'none';
    button2.innerHTML = "Pokaż kod";
  }
}
```

</div>

```{js, echo=FALSE}
const my_div2 = document.getElementById("przygotowywanie-zbiorow");
  my_div2.style.display = 'none';
  
var button2 = document.getElementById("my_button2");
  
function myFunction2() {
  if (my_div2.style.display === 'none') {
    my_div2.style.display = 'block';
    button2.innerHTML = "Ukryj";
  } else {
    my_div2.style.display = 'none';
    button2.innerHTML = "Pokaż";
  }
}
```

#### Testy 

```{r eval=FALSE}
pgn <- read.table("D:\\moje\\projekty\\chess-in-the-digital-age\\Dataset\\2024\\03. Mar\\Data_2024-03.pgn", quote="", sep="\n", stringsAsFactors=FALSE)


pgn.df <- data.frame(matrix(sub("\\[\\w+ \\\"(.+)\\\"\\]", "\\1", pgn[,1]),
                            byrow=TRUE, ncol=1))
nrow(pgn.df)

library(forcats)
zmienne = fct_count(fct_infreq(sub("\\[(\\w+).+", "\\1", pgn[1:nrow(pgn.df),1])))

nrow(pgn.df)
?length
library(stringi)
ncol(pgn)
tail(pgn)
# get column names
colnms <- sub("\\[(\\w+).+", "\\1", pgn[1:17,1])

library(forcats)
fct_count(sub("\\[(\\w+).+", "\\1", pgn[1:36,1]))
# give columns 11 (the moves) and 12 (redundant results column) nice names
colnms[18] <- "Moves"

pgn.df <- data.frame(matrix(sub("\\[\\w+ \\\"(.+)\\\"\\]", "\\1", pgn[,1]),
                            byrow=TRUE, ncol=18))
names(pgn.df) <- colnms
```



